import img from './assets';

import { style } from '../../index';

export const Topic4_5 = () => {
  return (
    <div className={style}>
      <h1>
        Алгебраическое суммирование чисел с фиксированной запятой с использованием обратного и дополнительного кодов.
      </h1>
      <h2>Алгебраическое суммирование чисел с использованием обратного кода</h2>
      <p>
        При рассмотрении алгебраического суммирования разберём 4 случая, исчерпывающие все возможные ситуации, которые
        могут встретиться при выполнении операции сложения. Пусть складываемые числа Х и Y– целые, причём |Х| + |Y| &lt;
        2<sup>n</sup>.
      </p>
      <p>
        1. Х ≥ 0 и Y ≥ 0 и X + Y &lt; 2n .
        <br />В этом случае, [X ≥ 0]<sub>о</sub>+[Y ≥ 0]<sub>о</sub>=X+Y=[X + Y]<sub>о</sub>. Сложив обратные коды двух
        слагаемых, получаем обратный код суммы. То есть сложение в этом случае выполняется таким же образом, как и в
        прямом коде.
        <br /> Пример:
      </p>
      <img src={img.img1} alt="formula1" />
      <p>
        2. X ≥ 0, Y ≤ 0 и X + Y ≥ 0. Если сложим обратные коды двух слагаемых, то получим <br />
        [X ≥ 0〗<sub>о</sub>+[Y ≤ 0]
        <sub>о</sub>=X+Y+B - предварительный результат <br />
        [(X + Y) ≥ 0]<sub>о</sub>= X + Y - действительный результат
      </p>
      <p>
        Поэтому для перехода от предварительного результата к действительному необходима коррекция, нужно вычесть В. С
        учетом того, что для целых чисел В=2n-1, из воображаемого n+1 разряда результата нужно вычесть единицу и
        прибавить её к младшему разряду предварительного результата. Коррекцию можно выполнить путём прибавления в
        младший разряд суммы единицы, которая представляет собой перенос из знакового разряда.
        <br /> Пример:
      </p>
      <img src={img.img2} alt="formula2" />
      <p>
        3. X ≥ 0, Y ≤ 0 и X + Y ≤ 0 Если сложим обратные коды двух слагаемых, то получим <br />
        [X ≥ 0]<sub>о</sub>
        +[Y ≤ 0]<sub>о</sub>=X+Y+B - предварительный результат <br />
        [(X + Y) ≤ 0]<sub>о</sub>= X + Y+B - действительный результат <br />
        Замечаем, что в этом случае коррекция не требуется, и мы сразу получаем правильный результат.
        <br /> Пример:
      </p>
      <img src={img.img3} alt="formula3" />
      <p>
        При суммировании равных по модулю чисел с противоположными знаками получаем нулевой результат. В этом случае
        алгоритм суммирования остаётся таким же, а результат получается в виде 1.11…1, что соответствует обратному коду
        отрицательного нуля.
      </p>
      <p>
        4. X ≤ 0, Y ≤ 0 и |X + Y| &lt; 2<sup>n</sup>.
        <br /> Если сложим обратные коды двух слагаемых, то получим
        <br />
        [X ≤ 0]<sup>о</sup>+[Y ≤ 0]<sup>о</sup>=X+B+Y+B - предварительный результат
        <br />
        [(X + Y)≤ 0]<sup>о</sup>= X + Y+B - действительный результат
      </p>
      <p>
        Также, как и во втором случае для перехода от предварительного результата к действительному необходима
        коррекция, нужно вычесть В. Так как для целых чисел В=2<sup>n</sup>-1, то из воображаемого n+1 разряда
        результата нужно вычесть единицу и прибавить её к младшему разряду предварительного результата. Эту коррекцию
        можно выполнить путём прибавления в младший разряд суммы единицы, которая представляет собой перенос из
        знакового разряда.
        <br /> Пример:
      </p>
      <img src={img.img4} alt="formula4" />
      <p>
        Очевидно, что во всех рассмотренных случаях слагаемые можно поменять местами и при этом код суммы не изменится.
        Требуемая для реализации коррекции цепь представляет собой цепь переноса из знакового разряда в младший разряд
        сумматора, то есть сумматор замыкается в кольцо. Эта цепь может быть постоянно замкнутой, так как перенос
        возникает лишь тогда, когда действительно требуется коррекция предварительного результата.
      </p>
      <p>
        Подведя итог вышеизложенному, делаем следующий вывод по суммированию чисел в обратном коде:
        <br />
        1) обработка знаковых и цифровых разрядов чисел осуществляется по одинаковым правилам и при этом автоматически
        получается правильный знак результата; <br />
        2) исключена операция прямого вычитания.
      </p>
      <h2>Алгебраическое суммирование чисел с использованием дополнительного кода</h2>
      <p>Как и в случае обратного кода рассмотрим 4 возможных случая</p>
      <p>
        1. Х ≥ 0 и Y ≥ 0, a X + Y ≤ 2<sup>n</sup>
        При этом, [X ≥ 0]<sub>д</sub>+[Y ≥ 0]<sub>д</sub>=X+Y=[X+Y]<sub>д</sub>. Сложив дополнительные коды двух
        слагаемых, получаем дополнительный код суммы. То есть сложение в этом случае выполняется таким же образом, как и
        в прямом коде.
        <br />
        Пример:
      </p>
      <img src={img.img5} alt="formula5" />
      <p>
        2. X ≥ 0, Y ≤ 0 и X + Y ≥ 0.
        <br /> Если сложим дополнительные коды двух слагаемых, то получим
        <br />
        [X ≥ 0]<sub>д</sub>+[Y≤0]<sub>д</sub>=X+Y+С - предварительный результат <br />
        [(X + Y) ≥ 0]<sub>д</sub>= X + Y - действительный результат
        <br /> Для перехода от предварительного результата к действительному необходима коррекция, нужно вычесть С. С
        учетом того, что для целых чисел С=2n, из воображаемого n+1 разряда результата нужно вычесть единицу. Эта
        коррекция будет выполняться автоматически так, как в разрядной сетке этот разряд отсутствует.
        <br /> Пример:
      </p>
      <img src={img.img6} alt="formula6" />
      <p>
        3. X ≥ 0, Y ≤ 0 и X + Y ≤ 0<br /> Если сложим дополнительные коды двух слагаемых, то получим <br />
        [X ≥ 0 ]<sub>д</sub>
        +[Y ≤ 0]<sub>д</sub>=X+Y+С - предварительный результат <br />
        [X + Y ≤ 0]<sub>д</sub>= X + Y+С - действительный результат <br />
        Замечаем, что в этом случае коррекция не требуется, и мы сразу получаем правильный результат.
        <br /> Пример:
      </p>
      <img src={img.img7} alt="formula7" />
      <p>При суммировании чисел с противоположными знаками получаем нулевой результат в виде 0.00..0.</p>
      <p>
        4. X ≤ 0, Y ≤ 0 и |X + Y| ≤ 2<sup>n</sup>. <br />
        Если сложим дополнительные коды двух слагаемых, то получим
        <br />
        [X ≤ 0]<sub>д</sub>+[Y ≤ 0]_д=X+С+Y+С - предварительный результат
        <br /> [X + Y ≤ 0]<sub>д</sub>= X + Y+С - действительный результат <br /> Также, как и во втором случае для
        перехода от предварительного результата к действительному необходима коррекция, нужно вычесть С. Коррекция будет
        выполняться автоматически так, как в разрядной сетке этот разряд отсутствует.
        <br /> Пример:
      </p>
      <img src={img.img8} alt="formula8" />
      <p>
        Очевидно, что во всех рассмотренных случаях слагаемые можно поменять местами и при этом код суммы не изменится.
        Коррекция будет выполняться автоматически.
      </p>{' '}
      <p>
        Отличительная особенность суммирования чисел в дополнительном коде состоит только в сущности коррекции. Кроме
        отмеченной особенности все выводы, сделанные для обратного кода справедливы и для дополнительного кода.{' '}
      </p>
      <p>
        Однако обе методики обладают одним недостатком – они не позволяют обнаруживать переполнение разрядной сетки,
        которое может возникать в первом и четвертом случаях.
      </p>
      <p>Пример:</p>
      <img src={img.img9} alt="formula9" />
      <p>
        После коррекции получили неверный результат, который соответствует положительному значению суммы, хотя
        суммировали два отрицательных числа. В таких случаях цифровой автомат должен зафиксировать переполнение и
        немедленно остановиться, чтобы препятствовать дальнейшему распространению ошибки. Для этой цели в его состав
        нужно ввести аппаратные средства, которые анализируют знаки складываемых чисел и знак суммы и в случае их
        несоответствия вырабатывают сигнал прерывания.
      </p>
      <p>
        Другой вариант обнаружения переполнения разрядной сетки – использование модифицированных дополнительного и
        обратного кодов.
      </p>
    </div>
  );
};
