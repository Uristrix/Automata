import img from './assets';

import { style } from '../../../../index';

export const Topic4_7 = () => {
  return (
    <div className={style}>
      <h1>
        Умножение правильных дробей, представленных в прямом, дополнительном, обратном кодах на два в степени +/- k.
      </h1>
      <h2>1. Умножение чисел с фиксированной запятой (точкой) на 2 в степени +/-k</h2>
      <p>
        При выполнении алгебраического суммирования чисел с плавающей запятой, а также при выполнении операций умножения
        и деления чисел обоих типов часто приходится использовать операцию умножения числа на 2<sup>±k</sup>. Рассмотрим
        выполнение этой операций для чисел, представленных в формате с фиксированной запятой (точкой).
      </p>
      <h2>1.1. Умножение чисел, представленных в прямом коде, на 2 в степени +/-k</h2>
      <p>
        Пусть Х правильная дробь X=±0,X<sub>-1</sub> X<sub>-2</sub> .. X<sub>-n</sub>. Её представление в прямом коде в
        разрядной сетке цифрового автомата будет выглядеть так:
      </p>
      <img src={img.img1} alt="formula1" />
      <p>
        X= ±(X<sub>-1</sub> ∙ 2<sup>-1</sup>+ X<sub>-2</sub> ∙ 2<sup>-2</sup>+ … X<sub>-n</sub> ∙ 2<sup>-n</sup>)<br />
        После умножения Х на 2-k получим: <br />X ∙ 2<sup>-k</sup> = ±(X<sub>-1</sub> ∙ 2<sup>-k-1</sup>+ X<sub>-2</sub>
        ∙ 2<sup>-k-2</sup>+ … X<sub>-n</sub> ∙ 2<sup>-k-n</sup>).
      </p>
      <p>
        Очевидно, что знак результата будет совпадать со знаком Х. После записи результата в разрядной сетке получим:
      </p>
      <img src={img.img2} alt="formula2" />
      <p>
        Младшие k разрядов результата, начиная с X<sub>-n+k-1</sub> до X<sub>-n</sub> не могут быть представлены в
        разрядной сетке, поэтому они потеряются. Сравнивая представление исходного числа X и результата Х ∙ 2
        <sup>-k</sup> в разрядной сетке, замечаем, что умножение числа Х на 2<sup>-k</sup> равносильно сдвигу цифровой
        части кода числа на k разрядов вправо. Выдвигаемые в этом случае за пределы разрядной сетки k младших разрядов
        кода теряются. Тем самым вносится погрешность. Причём если Х &gt; 0 (когда X<sub>зн</sub> = 0), погрешность
        имеет отрицательный знак. То есть, в этом случае представляемый в разрядной сетке результат будет меньше, чем
        действительный.
      </p>
      <p>
        Если X &lt; 0 (когда X<sub>зн</sub> = 1), погрешность положительная. То есть, в этом случае представляемый в
        разрядной сетке результат будет превышать действительный. Для уменьшения погрешности необходимо предварительное
        округление числа Х. Обычно оно выполняется следующим образом. Если старший разряд отбрасываемой части равен
        единице, то к младшему разряду оставшейся части результата прибавляется единица. В противном случае – нет.
      </p>
      <p>Таким образом, получаем следующее правило умножения числа Х на 2 в степени –k.</p>
      <p>
        <em>
          Для того чтобы умножить число Х, представленное в прямом коде на 2 в степени –k, необходимо цифровую часть
          кода сдвинуть вправо на k разрядов. Выдвигаемые за пределы разрядной сетки разряды теряются и тем самым
          вносится погрешность. В освободившиеся слева разряды заносятся нули
        </em>
      </p>
      <p>
        Умножим Х на 2<sup>+k</sup>.
        <br /> X ∙ 2<sup>+k</sup> = ±(X<sub>-1</sub> ∙2<sup>k-1</sup>+ X<sub>-2</sub> ∙2<sup>k-2</sup>+ … X<sub>-n</sub>
        ∙2<sup>k-n</sup>).
      </p>
      <p>
        В разрядной сетке нет разрядов для представления старших k разрядов результата Х ∙ 2<sup>+k</sup>. По этой
        причине операция умножения на 2<sup>+k</sup> будет корректна, если только эти разряды равны нулю. Остальные
        разряды результата будут представлены в разрядной сетке цифрового автомата следующим образом:
      </p>
      <img src={img.img3} alt="formula3" />
      <p>
        <em>
          Таким образом, операция умножения числа на 2<sup>+k</sup> в прямом коде равносильна сдвигу влево на k разрядов
          цифровой части кода числа. В младшие k разрядов результата записываются нули. Старшие k разрядов кода числа Х
          теряются, и если они ненулевые, то это приводит к некорректному результату. Получившееся в результате
          умножения число, превосходит допустимый диапазон, и такая ситуация называется переполнением разрядной сетки.
        </em>
      </p>
      <p>
        <em>
          Формальным признаком переполнения разрядной сетки при умножении числа в прямом коде на 2<sup>+k</sup>является
          выдвижение из цифровой части разряда, отличного от нулевого.
        </em>
      </p>
      <h2>1.2. Умножение чисел, представленных в обратном коде, на 2 в степени +/-k</h2>
      <p>
        Рассмотрим выполнение операции умножения на 2 в степени +/-k чисел, представленных в обратном коде. В случае,
        если Х положительное число, то и его представление, и представление результата умножения на 2<sup>+/-k</sup> в
        обратном коде будут совпадать с представлением в прямом коде. Поэтому используем сформулированное в предыдущем
        разделе правило умножения числа на 2 в степени +/- k.
      </p>
      <p>
        По указанной причине, имеет смысл рассмотреть умножение отрицательных чисел. Тогда [X]<sub>о</sub> будет
        выглядеть так:
      </p>
      <img src={img.img4} alt="formula4" />
      <p>
        Результат умножения: X ∙ 2<sup>-k</sup> = -(X<sub>-1</sub> ∙ 2<sup>-k-1</sup>+ X<sub>-2</sub> ∙ 2<sup>-k-2</sup>
        + … X<sub>-n</sub> ∙ 2<sup>-k-n</sup>) в разрядной сетке будет выглядеть так.
      </p>
      <img src={img.img5} alt="formula5" />
      <img src={img.img6} alt="formula6" />
      <p>
        С учетом правила умножения положительных чисел на 2<sup>+/-k</sup>, установленного в предыдущем разделе, можем
        сформулировать следующее правило.
      </p>
      <p>
        <em>
          Для умножения числа, представленного в обратном коде на 2^(-k), необходимо цифровую часть кода сдвинуть на k
          разрядов вправо, а в освободившиеся k старших цифровых разрядов записать код знака числа. Такой сдвиг называют
          модифицированным сдвигом. Выдвигаемые за пределы разрядной сетки разряды теряются, и как в случае прямого кода
          вносится погрешность в представление результата.
        </em>
      </p>
      <p>
        Представим результат умножения числа X на 2<sup>+k</sup> в обратном коде.
        <br /> X ∙ 2<sup>+k</sup> = ±(X<sub>-1</sub> ∙ 2<sup>k-1</sup>+ X<sub>-2</sub> ∙ 2<sup>k-2</sup> + … X
        <sub>-n</sub>∙ 2<sup>k-n</sup>).
      </p>
      <p>
        Рассмотрим случай, когда Х ≤ 0. Как уже отмечалось выше, в противном случае, когда X положительное число,
        результат будет таким же, как и в случае использования прямого кода.
      </p>
      <img src={img.img7} alt="formula7" />
      <img src={img.img8} alt="formula8" />
      <p>
        В этом случае цифровые разряды кода сдвигаются влево на k разрядов, а в освободившиеся справа разряды заносятся
        единицы.
      </p>
      <p>Если бы число было положительным, то в освободившиеся справа разряды заносились бы нули.</p>
      <p>
        Обобщая эти два случая, можем сформулировать следующее правило выполнения умножения чисел, представленных в
        обратном коде.
      </p>
      <p>
        <em>
          Для умножения числа Х, представленного в обратном коде, на 2<sup>+k</sup> необходимо цифровую часть кода
          сдвинуть на k разрядов влево и в освободившиеся справа разряды записать знаковый разряд.
        </em>
      </p>
      <p>
        При выполнении умножения на 2<sup>+k</sup> возможно переполнение разрядной сетки. Как можно было видеть в
        предыдущем разделе, если при сдвиге влево кода положительного числа из его цифровой части выдвигаются ненулевые
        разряды, то это является признаком переполнения разрядной сетки. В случае же отрицательных чисел, с учетом того,
        что в обратном коде представляются их инвертированные разряды, признаком переполнения будет являться выдвижение
        из цифровой части нулевого разряда.
      </p>
      <p>
        <em>
          Обобщая эти случаи, можем утверждать, что формальным признаком переполнения при выполнении умножения чисел на
          2+k в обратном коде является выдвижение из цифровой части разряда, отличного от знакового.
        </em>
      </p>
      <h2>1.3. Умножение чисел, представленных в дополнительном коде, на 2 в степени +/-k</h2>
      <p>
        Случай, когда Х ≥ 0, не содержит никаких особенностей. Правило будет такое же, как и для прямого кода, поэтому
        рассмотрим случай когда X &lt; 0.
      </p>
      <img src={img.img9} alt="formula9" />
      <p>
        Как можно было видеть из предыдущих разделов, если k младших разрядов числа Х равны нулю, то при сдвиге вправо
        цифровых разрядов прямого и обратного кодов числа потери точности не происходило.
      </p>
      <p>
        В этом случае при вычислении [X &lt; 0]<sub>д</sub> после инвертирования цифровых разрядов числа получим k
        правых единиц и после прибавления единицы к младшему разряду появится перенос в k + 1 справа разряд разрядной
        сетки, то есть в разряд X<sub>-n+k</sub>. В этом же случае после взятия дополнительного кода от Х ∙ 2
        <sup>-k</sup>, также берём инверсию цифровых разрядов [X ∙ 2<sup>-k</sup>]<sub>п</sub>, после чего прибавляем
        единицу к крайнему справа разряду, то есть к X<sub>-n+k</sub>.
      </p>
      <p>
        Таким образом, умножение на 2<sup>-k</sup> числа Х, представленного в дополнительном коде, состоит в
        модифицированном сдвиге вправо на k разрядов. Если же правые k разрядов числа Х отличны от нуля, то при сдвиге
        вправо произойдёт потеря цифровых разрядов, что приведёт к неточному представлению результата. В этом случае
        взятие дополнительного кода от Х 2<sup>-k</sup> может отличаться на единицу младшего разряда от результата
        модифицированного сдвига на k разрядов вправо.
      </p>
    </div>
  );
};
