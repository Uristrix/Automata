import img from './assets';

import { style } from '../../../../index';

export const Topic4_10 = () => {
  return (
    <div className={style}>
      <h1>Умножение чисел, представленных в дополнительном коде с корректирующим шагом</h1>
      <p>Докажем утверждение.</p>
      <p>
        <b>Утверждение. </b>
        Если [Y]<sub>д</sub>=y<sub>0</sub>, y<sub>-1</sub> y<sub>-2</sub> y<sub>-3</sub> ... y<sub>-n</sub>, то само
        число Y = -y<sub>0</sub> + 0,y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> (1.1)
      </p>
      <p>
        <b>Доказательство. </b>Начнём доказательство с правой части.
      </p>
      <p>
        Если y<sub>0</sub> = 0, то Y = 0,y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> &gt; 0 ⇒ [Y]<sub>д</sub> = Y =
        0, y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> = y<sub>0</sub>, y<sub>-1</sub> y<sub>-2</sub> ... y
        <sub>-n</sub>
      </p>
      <p>
        Если y<sub>0</sub> = 1, то Y = -1 + 0, y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> &lt; 0, [Y]<sub>д</sub>=
        C + Y = 2 + Y = 2 - 1 + 0, y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> = 1, y<sub>-1</sub> y<sub>-2</sub>
        ... y<sub>-n</sub> = y<sub>0</sub>, y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub>, что и требовалось
        доказать.
      </p>
      <p>
        Следует напомнить, что С – вес воображаемого разряда, расположенного левее знакового. Для чисел с фиксированной
        запятой С=2. На основании этого утверждения получаем следующий алгоритм умножения чисел в дополнительном коде.
      </p>
      <p>
        [X]<sub>д</sub> · [Y]<sub>д</sub> = [X]<sub>д</sub> · (-y<sub>0</sub> + 0,y<sub>-1</sub> y<sub>-2</sub>
        ... y<sub>-n</sub>) = [X]<sub>д</sub> · (-y<sub>0</sub> · 2<sup>0</sup> + y<sub>-1</sub> · 2<sup>-1</sup> + y
        <sub>-2</sub> · 2<sup>-2</sup> + ... y<sub>-n</sub> · 2<sup>-n</sup>) (1.2)
      </p>
      <p>
        Как следует из выражения (1.2), необходимо выполнить умножение множимого на все разряды множителя, причём
        результат умножения на знаковый разряд множителя взять с отрицательным знаком. Этот шаг называется поправкой или
        корректирующим шагом. По этой причине рассмотренный алгоритм называется умножением в двоичном коде с
        корректирующим шагом.
      </p>
      <p>
        С решением примера можно ознакомиться ниже или по ссылке: <br />
        <a href="https://1drv.ms/p/s!AmTg9edKbdanhm-uUOlMNdsAg9Fa?e=vlGw9z">
          https://1drv.ms/p/s!AmTg9edKbdanhm-uUOlMNdsAg9Fa?e=vlGw9z
        </a>
      </p>
      <p>Пример: </p>
      <img src={img.img1} alt="formula1" />
      <p>Пример: </p>
      <img src={img.img2} alt="formula2" />
      <p>
        Получили такой же результат, что свидетельствует о правильности решения. Последний пример отличается от
        предыдущего тем, что операнды взяты с противоположным знаком.
      </p>
    </div>
  );
};
