import img from './assets';

import { style } from '../../../../index';

export const Topic4_12 = () => {
  return (
    <div className={style}>
      <h1>Умножение в обратном коде</h1>
      <p>
        Будем использовать подход, рассмотренный выше при обосновании способа умножения чисел в дополнительном коде.
        Выразим число, которое представлено в обратном коде через его обратный код. Докажем утверждение.
      </p>
      <p>
        <b>Утверждение</b>
      </p>
      <p>
        Если [Y]<sub>о</sub> = y<sub>0</sub>, y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub>, то Y = 0, y<sub>1</sub>{' '}
        y<sub>-2</sub> ... y<sub>-n</sub> + y<sub>0</sub> (-1+2<sup>-n</sup>) (1.1).
      </p>
      <p>
        <b>Доказательство</b>
      </p>
      <p>Доказательство проведём также, как и в случае дополнительного кода. Начнём с правой части.</p>
      <p>
        Если y<sub>0</sub> = 0, то Y = 0, y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> &gt; 0, [Y]<sub>о</sub> = Y =
        0, y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> = y<sub>0</sub>, y<sub>-1</sub> y<sub>-2</sub> ... y
        <sub>-n</sub>.
      </p>
      <p>
        Если y<sub>0</sub> = 1, то Y = 0,y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> - 1 + 2<sup>-n</sup> &lt; 0,
        [Y]<sub>о</sub> = B + Y = 2 - 2<sup>-n</sup> + 0, y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> - 1 + 2
        <sup>-n</sup> = 1, y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> = y<sub>0</sub>, y<sub>-1</sub> y
        <sub>-2</sub> ... y<sub>-n</sub>
      </p>
      <p>
        Следует напомнить, что В - максимальное число без знака, которое может быть представлено в разрядной сетке
        цифрового автомата. В нашем случае для чисел с фиксированной запятой В=2-2<sup>-n</sup>.
      </p>
      <h2>Умножение в обратном коде с корректирующими шагами</h2>
      <p>
        В соответствии с (1.1) алгоритм умножения чисел в обратном коде следующий. Необходимо умножить множимое на
        цифровые разряды множителя. Если знаковый разряд множителя равен 1, то потребуется поправка (коррекция), которая
        заключается в прибавлении множимого со знаком «-» и в прибавлении [X]<sub>o</sub> · 2<sup>-n</sup>. Следует
        напомнить, что вторая часть поправки представляет собой множимое, сдвинутое на n разрядов вправо.
      </p>
      <p>
        [X]<sub>o</sub> · [Y]<sub>o</sub> = [X]<sub>o</sub> · (0, y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub>) -
        [X]<sub>o</sub> + [X]<sub>o</sub> · 2<sup>-n</sup> (поправка)
      </p>
      <p>Пример: </p>
      <img src={img.img1} alt="formula1" />
      <p>
        С учетом того, что перемножаемые числа равны 9/16 и 2/16 делаем заключение о правильности найденного результата.
        Знаковый разряд множителя равен нулю, поэтому корректирующие шаги не выполняем.
      </p>
      <p>Пример:</p>
      <img src={img.img2} alt="folmula2" />
      <p>
        Этот пример отличается от предыдущего наличием в знаковом разряде множителя единицы. Следовательно, для
        получения правильного результата потребуется коррекция, состоящая из двух шагов. Добавим корректирующие шаги к
        результату, полученному в предыдущем примере.
      </p>
      <img src={img.img3} alt="formula3" />
      <p>
        Следует напомнить, что в случае обратного кода неиспользуемые младшие разряды разрядной сетки заполняются
        знаковым.
      </p>
      <p>
        Таким образом, умножение выполняется за n шагов, если множитель положительный, и за n + 2 шага, если множитель
        отрицательный.
      </p>
      <h2>Умножение в обратном коде, с использованием преобразования разрядов множителя, если он отрицательный</h2>
      <p>Существует ещё один способ умножения в обратном коде. В соответствии с (1.1).</p>
      <p>
        [X]<sub>o</sub> · [Y]<sub>o</sub> = [X]<sub>o</sub> · (0, y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> + y
        <sub>0</sub>
        (-1+2<sup>-n</sup>))
      </p>
      <p>
        Если y<sub>0</sub> = 0, то умножение выполняется на цифровые разряды множителя без каких-либо особенностей.
      </p>
      <p>
        Если y<sub>0</sub> = 1, то [X]<sub>o</sub> · (0,y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> + y_0 (-1 + 2
        <sup>-n</sup>)) = [X]<sub>0</sub> · (0, y<sub>-1</sub> y<sub>-2</sub> ... y<sub>-n</sub> - 0,11 ... 1) = [X]
        <sub>o</sub> · (0, (y<sub>-1</sub> - 1) (y<sub>-2</sub> - 1) ... (y<sub>-n</sub> - 1)) = [X]<sub>o</sub> · (0, y
        <sub>-1</sub> y<sub>-2</sub> … y<sub>-n</sub>), где y<sub>-i</sub> = y<sub>-i</sub> - 1
      </p>
      <p>
        Способ называется умножением в обратном коде, путём преобразования разрядов множителя, если последний
        отрицательный. Преобразование заключается в вычитании из каждого разряда множителя знакового разряда. В этом
        случае формально множитель становится положительным, однако в цифровых разрядах будут присутствовать значения 0
        и -1.
      </p>
      <p>Пример:</p>
      <img src={img.img4} alt="formula4" />
      <p>
        Следует обратить внимание на то, что в отличие от прямого и дополнительного кодов при выполнении умножения чисел
        в обратном коде неиспользуемые младшие разряды разрядной сетки должны заполняться знаковым разрядом.
      </p>
    </div>
  );
};
