import img from './assets';

import { style } from '../../index';

export const Topic4_14 = () => {
  return (
    <div className={style}>
      <h1>Деление с восстановлением остатка и без восстановления</h1>
      <h2>Деление чисел, представленных в прямом коде с восстановлением остатка</h2>
      <p>Как и прежде используем формат представления чисел с фиксированной запятой.</p>
      <p>
        [X]<sub>п</sub> = х<sub>зн</sub>, х<sub>-1</sub> х<sub>-2</sub> ... х<sub>-n</sub> – делимое, это число, которое
        делим.
      </p>
      <p>
        [Y]<sub>п</sub> = y<sub>зн</sub>, у<sub>-1</sub> у<sub>-2</sub> ... у<sub>-n</sub> – делитель, это число, на
        которое делим.
      </p>
      <p>
        [Z]<sub>п</sub> = z<sub>зн</sub>, z<sub>-1</sub> z<sub>-2</sub> ... z<sub>-n</sub> – частное, это результат.
      </p>
      <p>Для нахождения частного надо выполнить 2 этапа:</p>
      <img src={img.img1} alt="formula1" />
      <p>Предположим, что модуль частного найден и он выглядит так.</p>
      <img src={img.img2} alt="formula2" />
      <p>
        Так как система двоичная, то коэффициент z<sub>-i</sub>=1 или 0, то есть либо |Y| · 2<sup>-i</sup> входит в
        разложение |Х|, либо не входит. Следовательно, для нахождения разрядов частного необходимо разложить |X| по
        составляющим |Y| · 2<sup>-i</sup>.
      </p>
      <p>Как это сделать? Путём вычитания.</p>
      <p>
        |X| - |Y| = α<sub>0</sub>, если получившийся остаток α<sub>0</sub> ≥ 0,то |X| = 1 · |Y| + α<sub>0</sub>.
        Следовательно разряд z<sub>0</sub> = 1.
      </p>
      <p>
        Делимое по модулю больше делителя. Значит, частное будет больше единицы и в формате с фиксированной 55 его
        представить нельзя. Поэтому, условие z<sub>0</sub> = 1 можно использовать в качестве формального признака
        переполнения разрядной сетки при делении.
      </p>
      <p>
        Если а<sub>0</sub> &lt; 0, то разряд z<sub>0</sub> = 0. Переполнения нет, продолжаем находить остальные разряды
        частного. Для нахождения разряда z<sub>-1</sub> вычисляем следующий остаток а<sub>1</sub>.
      </p>
      <p>
        |X| - |Y| · 2<sup>-1</sup> = α<sub>-1</sub>, если α<sub>1</sub> ≥ 0, то |X| = 1 · |Y| · 2<sup>-1</sup> + α
        <sub>1</sub>,<br /> следовательно z<sub>-1</sub> = 1. Для нахождения следующего разряда z<sub>-2</sub>,
        определяем остаток а<sub>2</sub>.
      </p>
      <p>
        α<sub>1</sub> = |Y| · 2<sup>-2</sup> + α<sub>2</sub>. И так далее.
      </p>
      <p>
        Для поиска дальнейших коэффициентов необходимо взять последний положительный остаток. Либо его надо хранить,
        тогда потребуется дополнительный регистр, либо восстановить α<sub>i</sub> = α<sub>i+1</sub> + Y · 2
        <sup>-i-1</sup>. Поэтому такой способ называют делением с восстановлением остатка.
      </p>
      <p>Пример:</p>
      <img src={img.img3} alt="formula3" />
      <p>
        |Z| = 0,1101 [Z]<sub>n</sub> = 0,1101 = 13/16 = 0,8125 Правильный результат 9/11= 0,818 … Погрешность составила
        0,056 ...
      </p>
      <p>
        Ближайшее число, которое можно представить в разрядной сетке 0,1110=14/16=0,875 имеет большую погрешность
        0,0625.
      </p>
      <p>
        Для нахождения более точного результата необходимо увеличить количество разрядов в разрядной сетке цифрового
        автомата.
      </p>
      <p>
        Недостатком рассмотренного способа деления является необходимость восстанавливать остаток после получения
        отрицательного остатка.
      </p>
      <p>Рассмотрим подробнее в чём состоит восстановление остатка.</p>
      <p>
        α<sub>i</sub> - |Y| · 2<sup>-i-1</sup> = α<sub>i+1</sub> &lt; 0
      </p>
      <p>
        α<sub>i</sub> = α<sub>i+1</sub> + |Y| · 2<sup>-i-1</sup> – восстановление остатка
      </p>
      <p>На следующем шаге после восстановления выполняем:</p>
      <p>
        α<sub>i+2</sub> = α<sub>i+1</sub> + |Y| · 2<sup>-i-1</sup> - |Y| · 2<sup>-i-2</sup> = α<sub>i+1</sub> + 2 · |Y|
        · 2<sup>-i-2</sup> - |Y| · 2<sup>-i-2</sup> = α<sub>i+1</sub> + |Y| · 2<sup>-i-2</sup>
      </p>
      <p>
        Таким образом, вместо восстановления и последующего вычитания сдвинутого на один разряд вправо модуля делителя
        |Y| · 2<sup>-i-2</sup> можно выполнить его прибавление к отрицательному остатку. Получаем другой способ деления.
      </p>
      <h2>Деление чисел, представленных в прямом коде, без восстановления остатка со сдвигом делителя</h2>
      <p>
        Формально способ деления в прямом коде запишется так. Вначале находим α<sub>0</sub> = |X| − |Y|. Если α
        <sub>0</sub> ≥ 0, то z<sub>0</sub> = 1 – переполнение разрядной сетки.
      </p>
      <p>
        Если α<sub>0</sub> &lt; 0, то продолжаем.
      </p>
      <img src={img.img4} alt="formula4" />
      <p>
        Если получаем положительный остаток α<sub>i+1</sub>, то соответствующий разряд частного z<sub>−i−1</sub> = 1,
        иначе z<sub>−i−1</sub> = 0.
      </p>
      <p>
        Если α<sub>i+1</sub> ≥ 0, то z<sub>−i−1</sub> = 1.
      </p>
      <p>
        Если α<sub>i+1</sub> &gt; 0, то z<sub>−i−1</sub> = 0.
      </p>
      <p>Пример:</p>
      <img src={img.img5} alt="formula5" />
      <p>
        Получили результат, совпадающий с результатом, найденным в предыдущем примере. Однако в отличие от предыдущего
        примера дважды восстанавливать остаток не потребовалось.
      </p>
      <h2>Деление чисел, представленных в прямом коде, без восстановления остатка со сдвигом остатка</h2>
      <p>
        Рассмотренный в предыдущем разделе способ деления чисел сводился к вычислению знака остатка на каждом шаге. При
        этом к предыдущему остатку в зависимости от его знака мы прибавляли или вычитали сдвинутый на один разряд вправо
        делитель. Для выполнения этого шага нам требовался сумматор разрядностью 2n. Однако знаки остатков не изменятся,
        если делитель не сдвигать вправо, а оставить неподвижным, но сдвинуть влево остаток. Другими словами, вместо
        уменьшения в два раза делителя и прибавления или вычитания его из остатка мы будем увеличивать остаток в два
        раза, а потом прибавлять или вычитать неподвижный делитель.
      </p>
      <p>Пример:</p>
      <img src={img.img6} alt="formula6" />
      <p>Получили результат, совпадающий с полученными в предыдущих примерах.</p>
    </div>
  );
};
